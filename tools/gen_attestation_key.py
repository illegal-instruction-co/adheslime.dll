#!/usr/bin/env python3
"""
Generate ECDSA P-256 keypair for DLL attestation.

Outputs:
  - src/attestation_key.gen.h  (XOR-obfuscated private key blob for DLL)
  - include/bigbro/attestation_pubkey.h (public key blob for host verification)

Uses Windows CNG-compatible blob format (BCRYPT_ECCPRIVATE_BLOB / BCRYPT_ECCPUBLIC_BLOB).
"""
import sys
import os
import struct

try:
    from cryptography.hazmat.primitives.asymmetric import ec
    from cryptography.hazmat.primitives import serialization
except ImportError:
    print("pip install cryptography")
    sys.exit(1)

OBF_KEY = 0xA7

def obfuscate(data: bytes) -> bytes:
    return bytes(b ^ ((OBF_KEY + (i * 0x37)) & 0xFF) for i, b in enumerate(data))

def to_cng_private_blob(private_key) -> bytes:
    """Build BCRYPT_ECCPRIVATE_BLOB (ECDSA_P256)."""
    # Magic: ECDSA P-256 private = 0x32534345 ('ECS2')
    # cbKey: 32
    nums = private_key.private_numbers()
    pub = nums.public_numbers
    x = pub.x.to_bytes(32, 'big')
    y = pub.y.to_bytes(32, 'big')
    d = nums.private_value.to_bytes(32, 'big')
    # BCRYPT_ECCKEY_BLOB header: dwMagic(4) + cbKey(4) + X(32) + Y(32) + d(32)
    header = struct.pack('<II', 0x32534345, 32)  # ECS2, 32
    return header + x + y + d

def to_cng_public_blob(private_key) -> bytes:
    """Build BCRYPT_ECCPUBLIC_BLOB (ECDSA_P256)."""
    # Magic: ECDSA P-256 public = 0x31534345 ('ECS1')
    nums = private_key.private_numbers().public_numbers
    x = nums.x.to_bytes(32, 'big')
    y = nums.y.to_bytes(32, 'big')
    header = struct.pack('<II', 0x31534345, 32)  # ECS1, 32
    return header + x + y

def main():
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <priv_output.gen.h> <pub_output.h>")
        sys.exit(1)

    priv_path = sys.argv[1]
    pub_path = sys.argv[2]

    # Generate ECDSA P-256 keypair
    private_key = ec.generate_private_key(ec.SECP256R1())

    # Build CNG blobs
    priv_blob = to_cng_private_blob(private_key)
    pub_blob = to_cng_public_blob(private_key)

    # Obfuscate private key
    enc_priv = obfuscate(priv_blob)

    # Write private key header (for DLL)
    with open(priv_path, 'w') as f:
        f.write("// AUTO-GENERATED by gen_attestation_key.py — DO NOT EDIT\n")
        f.write(f"// ECDSA P-256 private key blob ({len(enc_priv)} bytes, XOR-obfuscated)\n")
        f.write(f"static constexpr uint8_t kEncPrivateKey[{len(enc_priv)}] = {{\n    ")
        for i, b in enumerate(enc_priv):
            f.write(f"0x{b:02X}")
            if i < len(enc_priv) - 1:
                f.write(", ")
            if (i + 1) % 12 == 0:
                f.write("\n    ")
        f.write("\n};\n")

    # Write public key header (for host)
    with open(pub_path, 'w') as f:
        f.write("// AUTO-GENERATED by gen_attestation_key.py — DO NOT EDIT\n")
        f.write(f"// ECDSA P-256 public key blob ({len(pub_blob)} bytes)\n")
        f.write("// Use with BCryptImportKeyPair(BCRYPT_ECCPUBLIC_BLOB)\n")
        f.write("#pragma once\n")
        f.write("#include <cstdint>\n\n")
        f.write(f"static constexpr uint8_t kAttestationPubKey[{len(pub_blob)}] = {{\n    ")
        for i, b in enumerate(pub_blob):
            f.write(f"0x{b:02X}")
            if i < len(pub_blob) - 1:
                f.write(", ")
            if (i + 1) % 12 == 0:
                f.write("\n    ")
        f.write("\n};\n")

    print(f"Generated: {priv_path} ({len(enc_priv)} bytes, obfuscated)")
    print(f"Generated: {pub_path} ({len(pub_blob)} bytes, public)")

if __name__ == "__main__":
    main()
